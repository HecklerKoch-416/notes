# 1.结构体大小计算问题

```cpp
class A{
  virtual void tst(){}
  int a;  
};
```

问A的大小是多少？(32位和64位)

首先明确以下几条规则：

1. 首先，类大小的计算遵循结构体的对齐原则

2. 类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响

3. 虚函数对类的大小有影响，是因为虚函数表指针带来的影响

4. 虚继承对类的大小有影响，是因为虚基表指针带来的影响

5. 空类的大小是一个特殊情况,空类的大小为1

32位下，虚函数指针大小4字节，类大小为4+4=8.

64位下，虚函数指针大小8字节，类大小为4+8+4=16字节。(内存对齐规则)

# 2.为什么要内存对齐？

因为大多数处理器不是按字节读取，而是按字读取。如果没有内存对齐，处理器会先读取一个字大小的数据，然后剔除多余的，造成更多的消耗。因此，采用内存对齐有利于提高访存效率。

追问：什么是流水线？

将一个指令分解成若干顺序执行的子任务，由不同执行机构执行这些子任务，而这些执行机构可以并行执行，从而实现多条指令的并行操作。

追问：流水线的好处是什么？

提高指令电路的吞吐率和效率。

扩展：流水线的缺点：

引入了流水线寄存器，造成了输入输出延迟；用电路复杂度换取了时间复杂度。

# 3.socket编程TCP调用send和recv时，为什么发送和接受字节大小不一样。

这里涉及TCP和UDP的区别，背过八股应该记得，UDP面向报文传输，TCP面向字节传输，在实际编程中这俩有什么区别，请看下面的分析：

UDP连续发送五个100字节报文，调用一次接收函数，收到100字节，想要全部接收，就要调用5次。

TCP连续发送五个100字节报文，(等待一会)，调用一次接收函数，收到500字节。

原因：TCP面向字节的含义是TCP流式传输。TCP将数据看成一串无结构字节流，没有边界；从TCP和UDP的首部也可以看出两者区别：UDP首部有报文长度，TCP首部没有报文长度字段。

# 4.UDP实现可靠传输

首先明确，TCP实现可靠传输，用到了以下机制：

1. 确认机制。

2. 重传机制。

3. 序号机制。

4. 重排机制。

5. 窗口机制。

UDP实现可靠传输，基本要实现上述机制。

## 4.1确认、序号、重排

在数据包的数据部分加上ACK,seq等字段，(不能加在报文首部，首部是固定的)，接收方增加一个缓冲区，按照序号对乱序到达的报文进行重排。

## 4.2重传机制

停等机制，GBN,SR。

发送方没有接到ack，重传发送报文；接收方缺失序号，通知发送方重传。

在UDP中需要加入定时器。

## 4.3滑动窗口

接受窗口rwnd，拥塞窗口cwnd，发送窗口取两者最小值。

拥塞控制机制：慢启动，拥塞避免，快速重传，快速恢复。

## 4.4其它需要注意的点

UDP面向报文，recv一次会读取一个完整报文。

在以太网环境下，以太网数据帧大小为1500字节，减去IP首部20字节，UDP首部8字节，剩余1472字节，因此要注意发送数据帧的大小。如果大小超过1472，要进行分片传输，在接收方进行重组，如果其中一个包丢失，那么这些数据将被丢弃。

Internet环境下，大小为576-20-8=548.

socket编程中，UDP包大小小于64K。用sendto函数发送时，数据大小不能超过65535-20-8=65507字节。

# 5.c++static

比较简单，分别答修饰局部变量，全局变量，函数，成员变量，成员函数。

追问修饰成员函数和成员变量

答所有对象共享static成员变量，static成员函数脱离对象，可以用类名+作用域访问。

# 6.c++const

主要问修饰成员函数

修饰this指针为const，不能通过this指针修改成员变量。

# 7.算法题

大数计算

依托，看看就行。

要求必须用字符串计算，从高位到低位。

```c
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <windows.h>
#include <windef.h>

const char* StringAdd(const char* a, const char* b) {
	if (!a)	return b;
	if (!b)	return a;
	int a_len = strlen(a);
	int b_len = strlen(b);
	char* c = (char*)malloc(max(a_len, b_len) + 1);
	memset(c, '0', max(a_len, b_len) + 1);
	int i = a_len - 1, j = b_len - 1, k = max(a_len, b_len);
	c[k + 1] = '\0';
	int flag=0;
	while (i >= 0 && j >= 0) {
		if (a[i]-'0' + b[j]-'0' + flag >= 10) {
			c[k--] = a[i--] - '0' + b[j--] - '0' + flag - 10 + '0';
			flag = 1;
		}
		else {
			c[k--] = a[i--] + b[j--] + flag - '0';
			flag = 0;
		}	
	}
	while (i>=0)
	{
		if (a[i] -'0' + flag >= 10) {
			c[k--] = a[i--] + flag - 10;
			flag = 1;
		}
		else {
			c[k--] = a[i--] + flag;
			flag = 0;
		}
	}
	while (j >= 0)
	{
		if (b[j] - '0' + flag >= 10) {
			c[k--] = b[j--] + flag - 10;
			flag = 1;
		}
		else {
			c[k--] = b[j--] + flag;
			flag = 0;
		}
	}
	if (flag == 1)
		c[0] = '1';
	return c;

}

int main() {
	char* a = (char*)malloc(20);
	char* b = (char*)malloc(20);
	scanf_s("%s", a, 20);
	scanf_s("%s", b, 20);

	const char* c = StringAdd(a, b);
	if(c[0]=='0')
		printf("%s", c+1);//没用动态数组，不进位开头多个0，肯定有更好的办法
	else
		printf("%s", c);
	free(a);
	free(b);

}

```
