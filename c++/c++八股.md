## 1.内存分布

栈：由编译器管理分配和回收，用于存放函数参数，局部变量等等。一般入栈顺序是从右到左入栈。

堆：由程序员自己管理，主要通过new, delete, malloc, free进行分配和回收，空间比较大，但有可能会存在内存泄漏和空闲碎片的情况。

全局/静态区：分为初始化和未初始化两个相邻的区域，存储初始化和未初始化的全局变量和静态变量。

常量区：用于储存常量，一般不允许修改。

代码区：用于存放程序的二进制代码。



## 2.堆分配内存底层原理

实际上，在分配内存时，系统中有一个空闲的内存链表，当程序员申请时，系统会遍历空闲链表，找到第一个内存空间大于或等于申请的空间分配给程序，一般在分配内存时，也会在内存头部写入内存的大小，目的是方便delete回收。



## 3.new和delete区别

1. new和delete是C++关键字，而malloc和free是C语言库函数。new从自由存储区上分配内存，malloc从堆上分配内存。

2. new/delete会调用构造函数/析构函数对对象进行初始化与销毁：
   
   new在调用时，是先分配内存，再调用构造函数，delete在调用时先使用析构函数，再释放内存，而malloc只分配内存，free只释放内存。故而，new比malloc更安全，因为，他会调用构造和析构函数。

3. 返回值与内存大小计算：
   
   new申请内存不需要计算申请内存的大小，且不需要强制类型转换，其返回的类型就是对应申请类型的指针，而malloc申请时，需要手动计算申请内存的大小，并且还需要强制类型转换为需要的类型，因为malloc返回的类型为 void*。

4. new申请内存失败，返回NULL，而malloc申请内存失败，则返回异常。



## 4.为什么要用new/delete

在C语言中 并没有专门针对于自定义类型使用的内存开辟函数和释放函数 ，有的只是针对于内置类型的函数（malloc、realloc、free），并没有专门给自定义类型使用的函数，所以在我们的C++中有了类和对象的概念之后，自定义类型变得是更加的重要，所以为了专门给自定义类型的内存申请和释放。



## 5.函数参数传递

值传递：形参是实参的拷贝，形参的改变并不影响实参。

指针传递：也是值传递的一种，不过形参接收的是实参的地址，对形参所指对象进行操作，及等价于对实参的操作。

引用传递：实际上就是把引用对象的地址放在了所开辟的栈空间中，函数对其形参的操作可以直接映射到实参上。

指针传递与引用传递的区别：

指针参数传递本质上是值传递，它所传递的是一个地址值。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。



## 6.引用的实质

引用的实质是别名。

引用与指针的区别：

1. 引用必须在定义时初始化，不能修改引用的指向；指针定义式不必初始化，可以改变指针的指向。

2. 可以有 const 指针，但是没有 const 引用。

3. 指针可以有多级，但是引用只能有一级。

4. 对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1。

5. sizeof()大小不同，指针一般是四个字节，引用是数据类型的大小。



## 7.指针和数组区别

数组是用于存储多个相同类型的数据集合，数组名是首元素的地址，sizeof的大小是所有元素总大小。

指针：相当于一个变量，存储的是内存中的地址，sizeof的大小固定。

区别：同类型的指针可以相互赋值，而数组不行，数组只能一个一个元素的赋值或拷贝。



## 8.函数指针与指针函数

函数指针是一个指向函数的指针，指向函数的入口地址；而指针函数只是说明他是一个返回值为指针的函数。



## 9.野指针、悬挂指针

野指针：就是没有经过初始化的指针。

悬挂指针：就是最初指向的内存被释放后，未被置空的指针。

避免：对于野指针的避免，就是在定义指针后且在使用之前对指针进行初始化，或用智能指针。对于悬挂指针的避免，就是在内存释放后，即使的吧指针置空或调用智能指针。



## 10.常量指针与指针常量

```cpp
const  int  *p = &a 
//常量指针，指向可以改，但指向的值不可以改。
int  * const p = &a 
//指针常量，指向不可以改，但指向的值可以改
```



## 11.static

1. static修饰局部变量：局部变量一般存放在栈区，且局部变量的生命周期在所包含的语句块结束后而结束。通过static修饰后的局部变量存放在静态区，生命周期会一直延续到整个程序执行结束后而结束，但其作用域未发生改变。

2. static修饰全局变量：全局变量，一般存放在全局区，能够被整个程序所访问到，同时也能被同一个工程中的其他源文件所访问到（但是需添加extern声明）。通过static修饰过后，则该全局变量存放在静态区，且也改变了该变量的作用域，通过static修饰后，该全局变量只能在本文件中被访问到，而其他文件访问不到。

3. static修饰函数：与修饰全局变量一样，改变了其作用域。

4. static修饰类成员函数：如果类中的某个成员函数被static所修饰，那么该成员函数不属于该类的任何一个对象，他属于整个类，所有对象共享同一个函数，因此不包含this指针。同时该函数也只能访问类中的静态变量，而不能访问其他成员变量和成员函数。

5. static修饰类成员变量：如果static修饰类中的成员变量，那么该变量就归所有的对象，存储空间中也只有一个副本，所有对象共享同一份数据，可以通过类或对象直接进行调用。
   
   
   

## 12.const

1. const修饰基本数据类型：使得这些变量变为常量，其值不可更改。

2. 常量指针、指针常量。

3. const修饰成员变量：const修饰的成员变量的初始化只能在构造函数中使用列表初始化。

4. const修饰成员函数：在成员函数后加const，表示就是成员函数不可以更改成员变量，如果需要修改某个变量，将变量声明为mutable。
   
   ```cpp
   int a() const;
   ```

5. const修饰类：定义常量对象，常量对象只能调用常量函数，不可以调用其他函数。



## 13.mutable

mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。



## 14. volatile

表示对象会被当前执行的代码流之外的东西所修改，变量被volatile修饰的时候，编译器在读取该变量的值时，每次都会去内存地址中重拿一次。而且读取的数据立刻被保存。

问题：

```cpp
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```

由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。如果 i是一个寄存器变量或者表示一个端口数据就容易出错。

应用场景：中断、多任务、存储器映射寄存器。



## 15. #define与const区别

1. 类型和安全检查不同：宏定义只是字符的替换，没有数据类型的区别，同时这种替换也没有类型安全检查，而const常量是常量的声明，有数据类型的区别，同时在编译阶段也会有类型的检查。

2. 编译器处理的不同：宏是一个“编译时”概念，编译器在预处理阶段就把宏给展开，不能对宏进行调试；而const是一个“运行时”概念，编译器在编译阶段处理const变量，类似于一个只读数据。

3. 存储方式的不同：宏定义是直接替换，没有内存分配，存储于代码段中；而const常量有内存分配，存储于数据段中。

4. 定义域不同：宏定义是全局定义，可以在整个程序中使用，而const是一个局部定义，只能在定义的地方使用。



## 16.c和c++区别

1. 语法上：语法上C++的区别有头文件和命名空间的不同，C++允许我们自定义自己的空间，而C不可以；在关键字方面也有不同，如C++在动态内存管理上增加了new和delete，在指针上，C++增加了引用的概念，C++在关键字上，也还增加了auto类型等等。

2. 函数上：C++支持函数重载，而C不支持。

3. struct上：C的struct像是一个数据结构的集合，而C++的struct不仅成员函数，还有成员变量，同时还增加了访问权限的概念。

4. C是面向过程的语言，而C++是面向对象的语言，C++在C的基础上最大的变化就是增加了类的概念。



## 17.c++ struct和class区别

主要的区别在于默认访问权限和默认继承权限不同，struct的默认访问权限和默认继承权限都是public，而class是private。










