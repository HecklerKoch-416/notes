# 1.什么是进程/什么是线程

进程是资源分配和调度的一个独立单位；而线程是进程的一个实体，是CPU调度和分配的基本单位。

# 2.并行与并发。

并行指的是多个任务在同一时刻同时在执行。

并发是指在一个**时间段内**，多个任务交替进行。虽然看起来像在同时执行，但其实是交替的。

# 3.c++线程管理

启动：创建线程对象。

结束：join阻塞，等待释放资源；detach分离线程，在后台自主运行。

转移所有权：move。

异常处理：try/catch；资源获取即初始化，封装一个线程基类，使其在生命周期结束后自动调用析构函数时释放资源。

# 4.线程同步与互斥

## 4.1什么是同步，什么是互斥

- 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。
- 线程互斥是指对于共享的操作系统资源，在各线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。
- 线程互斥是一种特殊的线程同步。

## 4.2同步机制

+ 临界区：是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。

+ 事件：通过通知操作的方式来保持线程的同步，并且能够实现不同进程中的线程同步操作。

+ 信号量：信号允许多个线程同时使用共享资源，但是需要限制在同一时刻访问此资源的最大线程数目。

+ 互斥量：只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。

## 4.3锁机制

+ 互斥锁：一种简单的加锁的方法来控制对共享资源的访问。

+ 条件变量：当某一线程满足某个条件时，可以使用条件变量令该程序处于阻塞状态；一旦该条件状态发生变化，就以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。

+ 自旋锁：当发生阻塞时，互斥锁会让CPU去处理其他的任务，而自旋锁则会让CPU一直不断循环请求获取这个锁。

+ 读写锁：允许多个线程同时执行读操作，只有一个线程可以执行写操作。

+ 递归锁：在同一个线程在不解锁的情况下，可以多次获取锁定同一个递归锁，而且不会产生死锁。

## 4.4原子操作

使用atomic可以避免使用锁，而且更加底层，比mutex效率更高。

为了避免多个线程同时修改了counter这个数导致出现错误，只需要把counter的原来的int型，改为atomic_int型就可以了，非常方便，也不需要用到锁。

```cpp
#include <thread>
#include <iostream>
#include <vector>
#include <atomic>

using namespace std;

void func(int& counter)
{
    for (int i = 0; i < 100000; ++i)
    {
        ++counter;
    }
}

int main()
{
    //atomic<int> counter(0);
    atomic_int counter(0); //新建一个整型原子counter，将counter初始化为0
    //int counter = 0;
    vector<thread> threads;
    for (int i = 0; i < 10; ++i)
    {
        threads.push_back(thread(func, ref(counter)));
    }
    for (auto& current_thread : threads)
    {
        current_thread.join();
    }
    cout << "Result = " << counter << '\n';
    return 0;
}
```

# 5.c++数据库如何保证线程安全

答：

悲观锁和乐观锁，悲观锁认为读少写多，所以每次读写都上锁；乐观锁认为读多写少，不上锁，但是会进行版本号控制。

版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

# 6.什么是死锁，死锁产生条件

所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

四个条件：

互斥：进程对资源有排他性占有要求。

不剥夺：进程资源只能主动释放。

请求和保持条件：进程已经占有部分资源，又申请新的资源，并对占有的资源保持不放。

循环等待：进程间形成了循环等待链，一个进程请求的资源被下一个进程占有。

# 7.进程通信

## 7.1匿名管道

在父子进程间使用，子进程可以使用父进程的资源。

fork()函数：调用一次可有多个返回值。在父进程中，fork返回创建的子进程的进程id；在子进程中，fork返回0；出错返回负值。

fork创建一个子进程，复制父进程所有信息，并用父进程PCB初始化自己的PCB。

父子进程通过fork后，子进程继承了父进程的文件描述符。所以他们指向同一个数据结构。文件描述符有一个读端和一个写端，父子进程各使用一端。

最大64KB。

## 7.2有名管道

匿名管道只能用于父子进程通信，有名管道解决了这个问题。

创建一个管道文件fifo，**本身无大小**，在文件系统中以文件名的形式存在，通过路径对所有进程可见。文件作为通信介质。

## 7.3消息队列

直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛引用于计算机网络中，相应的通信系统称为电子邮件系统。

缺点：需要拷贝数据，速度较慢。

## 7.4共享内存

在通信的进程之间存在一块可直接访问的共享空间，需要通过同步和互斥控制读写。

## 7.5信号量

用于传递信号，实现进程间同步互斥。

## 7.6信号

用于传递信号，不携带数据。

## 7.7套接字socket
